\documentclass[acmtog]{acmart}
\usepackage[ngerman, english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\copyrightyear{2024}
\acmYear{2024}
\citestyle{acmauthoryear}

\usepackage[figurename=Fig.]{caption}
\setcopyright{none}
\makeatletter
\renewcommand{\fnum@figure}{Abb. \thefigure}
\makeatother
\addto\captionsngerman{\renewcommand{\figurename}{Abb.}}
\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column

\usepackage[cache=false]{minted}
\setminted{
    breaklines=true,
    frame=single,
}
\usepackage[minted, most]{tcolorbox}


\begin{document}

\hypersetup{
	colorlinks,
	allcolors=blue,
	citecolor=.,
}

\title{Requirements Engineering: User Stories und Epics in Vorgehensmodellen}

\author{Jonas Pohl}
\authornote{Alle Studierenden trugen zu gleichen Teilen zu dieser Arbeit bei.}
\author{Mose Schmiedel}
\authornotemark[1]
\author{Antonia Swiridoff}
\authornotemark[1]
\affiliation{%
	\institution{Hochschule für Technik, Wirtschaft und Kultur Leipzig (HTWK Leipzig)}
	\streetaddress{Karl-Liebknecht-Str. 132}
	\city{Leipzig}
	\country{Deutschland}
	\postcode{04277}
}

\renewcommand{\shortauthors}{Pohl, Schmiedel and Swiridoff}

\begin{abstract}
	In dieser Arbeit wurde der Einsatz und die Wirkung von Epics und User Stories in der agilen Softwareentwicklung untersucht.
	Dazu wurden drei agile Vorgehensmodelle und die beim Einsatz von Epics und User Stories
	auftretenden Herausforderungen betrachtet.
	Für die Herausforderungen wurden jeweils mögliche Lösungsvorschläge gefunden und anhand von kurzen Beispielen beschrieben.

	Im Verlauf der Recherche sind die Autoren zu dem Schluss gekommen, dass Epics und User Stories ein hilfreiches Werkzeug
	für das Requirements Engineering sind. Insbesondere für die agile Softwareentwicklung ist dieses Konzept besser geeignet als traditionelle
	Methoden.
\end{abstract}

\maketitle

\section{Einleitung und Motivation}
Moderne Softwareprojekte sind häufig geprägt von großer Komplexität.
Zunehmend dynamischen Rahmenbedingungen haben dazu geführt, dass traditionelle Entwicklungsansätze oft nicht mehr ausreichen.
Insbesondere mangelnde Flexibilität und unklare Spezifikationen können zu erheblichen Verzögerungen oder sogar zum Scheitern eines Projekts führen.
Als Reaktion darauf wurden in den letzten Jahrzehnten verschiedene agile Methoden entwickelt, die unter anderem eine schnellere Reaktion auf geänderte Anforderungen ermöglichen sollen.

In der agilen Softwareentwicklung werden häufig Epics und User Stories verwendet, um Anforderungen zu beschreiben und zu strukturieren.
% Epics dienen der Beschreibung übergeordneter Anforderungen, während User Stories ``kleinere'' Anforderungen klar und prägnant aus der Perspektive des Anwenders formulieren.
Die Verwendung von Epics und User Stories bringt dabei Herausforderungen mit sich, wie z.B. die sinnvolle Abgrenzung von Anforderungen, die richtige Detailtiefe, eine angemessene Priorisierung und die Aufwandsschätzung.

Ziel dieser Arbeit ist es, den Einsatz von Epics und User Stories im agilen Requirements Engineering zu untersuchen. Dabei werden typische Herausforderungen thematisiert und geeignete Lösungsansätze vorgestellt.

Diese Arbeit ist folgendermaßen strukturiert:
Kapitel 2 gibt einen Überblick über die Grundlagen des Requirements Engineerings.
Anschließend wird in Kapitel 3 das Konzept von User Stories und Epics vorgestellt und anhand eines Beispiels verdeutlicht.
In Kapitel 4 wird die automatische Verarbeitung von User Stories mit Hilfe von Cucumber erläutert.
Danach werden in Kapitel 5 konkrete agile Vorgehensmodelle und deren Umgang mit Anforderungen vorgestellt.
In Kapitel 6 werden die Vorteile und Risiken bei der Anwendung von User Stories diskutiert.
Abschließend werden in Kapitel 7 die wichtigsten Erkenntnisse zusammengefasst.

\section{Grundlagen Requirements Engineering}

\subsection{Definition und Einordnung}
Die \emph{Anforderungen} (engl. \textit{requirements}) an ein Softwaresystem beschreiben, welche Eigenschaften von der Software erwartet werden \cite{sommerville16}.
% Dabei kann es sich z.B. um Benutzeranforderungen aber auch Systemanforderungen handeln.
Ein einfaches Beispiel ist:
\begin{quote}
Der Benutzer muss sich mit seiner E-Mail-Adresse und einem Passwort anmelden können.
\end{quote}

Der Prozess, um solche Anforderungen ``zu ermitteln, zu spezifizieren, zu analysieren, zu validieren und daraus eine fachliche Lösung abzuleiten'', wird als \emph{Requirements Engineering} (\emph{RE}) bezeichnet \cite{balzert09}.
Das Ziel dieses Prozesses ist neben der Erarbeitung einer Anforderungsspezifikation die Qualität der Software und die Kundenzufriedenheit sicherzustellen.

Das Requirements Engineering gilt dabei als besonders kritisch, da es einerseits eine der komplexesten Teilbereiche des Software Engineerings darstellt und andererseits maßgeblich den Erfolg eines Softwareprojekts beeinflusst \cite{balzert09}.
Somit gehört das Requirements Engineering zu den größten Herausforderungen in der Softwareentwicklung.

Eine intensive Einbeziehung aller Personen oder Institutionen, die ein Interesse an der Software haben, direkt beteiligt oder von deren Nutzung betroffen sind, ist unerlässlich. Diese Personen oder Institutionen werden \emph{Stakeholder} genannt \cite{balzert09}.

\subsection{Funktionale und nichtfunktionale Anforderungen}
Häufig wird zwischen zwei Arten von Anforderungen unterschieden: Funktionale und nichtfunktionale Anforderungen. In \cite{sommerville16} werden diese folgendermaßen definiert:

\emph{Funktionale Anforderungen} legen fest, welche Dienste und Funktionen die Software bereitstellen soll. Sie beziehen sich häufig auf konkrete Nutzeranforderungen, wie die Reaktion auf bestimmte Eingaben oder das gewünschte Verhalten in einer konkreten Situation.

\emph{Nichtfunktionale Anforderungen} beziehen sich meist auf übergreifende Eigenschaften der Software oder auf mehrere Funktionen gleichzeitig. Dazu zählen Aspekte wie Zuverlässigkeit, Verfügbarkeit, Informationssicherheit und Antwortzeit. Dabei können nichtfunktionale Anforderungen auch Einschränkungen umfassen, z.B. dass für eine Schnittstelle ein bestimmtes Datenformat eingehalten werden muss.

Da sich Anforderungen häufig überschneiden, gegenseitig beeinflussen oder voneinander abgeleitet werden, können nicht alle Anforderungen eindeutig eine der beiden Kategorien zugeordnet werden. Die Anforderung ``Der Benutzer muss sich mit seiner E-Mail-Adresse und einem Passwort anmelden können.'' beschreibt zwar eine konkrete Funktion (Benutzeranmeldung), kann dabei aber zusätzlich nichtfunktionale Anforderungen beinhalten, wie z.B. eine kurze Antwortzeit oder hohe Sicherheitsstandards für die Verarbeitung der Anmeldedaten.

\subsection{Requirements Engineering in der agilen Entwicklung}
Bei der agile Softwareentwicklung, auf die sich dieser Artikel vorrangig konzentriert, gibt es wesentliche Unterschiede im Vergleich zur traditionellen bzw. plangesteuerten Softwareentwicklung.
Um schneller funktionsfähige Software bereitzustellen und flexibel auf Änderungen der Anforderungen reagieren zu können, wird in der agilen Entwicklung in der Regel auf eine detaillierte, vollständige  Anforderungsspezifikation verzichtet.
Stattdessen wechseln sich die Phasen des Requirements Engineerings und der Implementierung iterativ ab, sodass Spezifikation und Implementierung direkt ineinander greifen (siehe Abb. \ref{fig:development}).

Das Requirements Engineering erfolgt daher entwicklungsbegleitend, wobei die Stakeholder fortlaufend einbezogen werden. Auf diese Weise wird eine kontinuierliche Überprüfung und Anpassung der Anforderungen sichergestellt.
So können Änderungen schnell berücksichtigt und potenzielle Missverständnisse frühzeitig erkannt und mit geringerem Aufwand behoben werden.

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{images/plandriven-and-agil-development.png}
  \caption{Traditionelle und agile Softwareentwicklung \cite{sommerville16}}
    \label{fig:development}
  \Description{}
\end{figure}

\section{Epics und User Stories}
Wie dem \emph{Agile Manifesto} \cite{beedle_principles_2001} festgehalten, muss eine agile Softwareentwicklung
auf sich verändernde Anforderungen reagieren können.
Dies führt dazu, dass viele herkömmliche Methoden zur Anforderungsanalyse für diese Art von Softwareentwicklung
nicht mehr geeignet sind.

Um mit diesen Veränderungen im Requirements Engineering umzugehen, sind neue Werkzeuge und Konzepte
für diese Phase der Softwareentwicklung entstanden, welche die Prinzipien der agilen Softwareentwicklung
berücksichtigen und unterstützen.

Das Konzept von \emph{Epics und User Stories} gehört zu diesen neuen Methoden und soll das Entwicklerteam
während bei der Anforderungsanalyse unterstützen. Im folgenden Abschnitt werden die zugrundeliegenden Definitionen
dieses Konzeptes vorgestellt, anhand eines Beispiels verdeutlicht und die Vor- und Nachteile beleuchtet.

\subsection{Definition ``User Story''}
\cite[p. 4]{cohn_user_2004} beschreibt ``[e]ine \emph{User Story} [als] eine Funktionalität, welche wertvoll für einen Nutzer [...] eines Systems
oder Software ist''.
Diese Funktionalität wird dabei mit ein bis zwei Sätzen in folgender Struktur formuliert:

\vspace{1em}
\texttt{As a \underline{<type of user>}, I want to \underline{<goal>}\\
	\hspace*{13em} so that \underline{<achieved value>}.}
\begin{flushright}
	\cite[p. 499]{balzert09}
\end{flushright}


\vspace{.5em}

\verb|<Type of user>|, \verb|<goal>| und \verb|<achieved value>| stellen hierbei Platzhalter dar,
welche je nach Anforderung ausgefüllt werden müssen.
\cite{jeffries_essential_2001} unterteilt eine User Story in folgende drei Teile:
\begin{description}
	\item[Card] repräsentiert die Anforderung, strukturiert nach oben genannter Vorlage.
	\item[Conversation] findet als (verbale) Kommunikation der Anforderung zwischen Kunde und Entwickler oder Entwickler und Entwickler statt.
	\item[Confirmation] besteht aus den Akzeptanztests, welche die notwendigen Eigenschaften der Anforderung festlegen.
\end{description}

In vielen Fällen begegnet ein Entwickler der User Story durch die Card.
Diese wird aus Sicht des Kunden formuliert oder sogar von diesem verfasst \cite[p. 497]{balzert09}.

Auf der Card wird in wenigen Sätzen die in der User Story transportierte Anforderung zusammengefasst.
Dabei sei hervorgehoben, dass die Card nicht etwa als vollständige Spezifikation für die geforderte Funktionalität dient,
sondern lediglich als Erinnerung und Grundlage für spätere Diskussion.
Diese wird in der Conversation durchgeführt und gegebenenfalls dokumentiert.
Ziel der Conversation ist es dabei die Details der Funktionalität zu klären
und durch Akzeptanztests in der Confirmation als Spezifikation für die Implementierung
der Funktionalität festzuhalten \cite[p. 4]{cohn_user_2004}.

\subsection{Definition ``Epic''}
Ein \emph{Epic} stellt eine Vision oder ein übergeordnetes Ziel dar.
Es gleicht in der Formulierung der User Story, umfasst aber einen viel größeren Umfang \cite[pp. 6, 14]{cohn_user_2004}.
Das Epic repräsentiert nämlich nicht nur eine einzelne Anforderung, sondern einen Anforderungsbereich.
Somit bietet es dem Kunden und den Entwicklern eine Orientierungshilfe beim Formulieren der User Stories,
ist aber selber unbrauchbar für die direkte Implementierung von Software-Features.

Um den Zweck einer Vision zu erfüllen, werden Epics dementsprechend grob und allgemein formuliert.
Sie lassen einen weiten Interprationsspielraum offen, welcher durch weitere Absprachen zwischen
Kunde und Team, bzw. innerhalb des Entwicklerteams ausgefüllt werden müssen.

Die Vorlage für die Formulierung von User Stories kann selbstverständlich auch für Epics verwendet werden.
Dies bietet den Vorteil, dass schon die Vision aus der Perspektive des Kunden, bzw. des Stakeholders formuliert
wird. Dies vereinfacht gegebenenfalls das spätere Formulieren von User Stories.

\subsection{Beispiel}
Um das Konzept der \emph{Epics und User Stories} besser zu verdeutlichen, wurden alle Beispiele in diesem
Artikel für ein imaginäres Kursverwaltungssystem erstellt.
Dieses System soll Mitgliedern einer Hochschule die digitalen Verwaltung von Kursen und deren zugehörigen Informationen
und Prüfungen ermöglichen.
Außerdem sollen Studierende in der Lage sein, sich zu Kursen, bzw. Prüfungen an- und abzumelden.

Für dieses System wird in diesem Abschnitt am Beispiel eines spezifischen Epics der Umgang mit Epics und User Stories erläutert.

Das Epic ist basierend auf der Vorlage aus dem vorhergehenden Abschnitt formuliert.
Dabei sind die Phrasen, welche für die Platzhalter eingesetzt wurden, unterstrichen.

Das gewählte Epic lautet wie folgt:

\vspace{1em}
\texttt{Als \underline{Professor} möchte ich \underline{meine Kurse digital }\\
	\hspace*{3em}\underline{ verwalten}, damit \underline{die Studierenden }\\
	\hspace*{4em} \underline{ unabhängig mit diesen interagieren können}.}
\vspace{1em}

Wie schon in der Definition des Epics angesprochen handelt es sich bei einem Epic um ein umfangreiches
Arbeitspaket, welches mehr eine Vision oder größeres Ziel ausdrückt, als eine einzelne Anforderung.
Im Beispiel ist dies unschwer durch den Gebrauch von groben Formulierungen zu erkennen. So wird zum
Beispiel lediglich festgelegt, dass ein \underline{\texttt{Professor}} seine \underline{\texttt{Kurse digital verwalten}}
möchte. Diese Formulierung lässt einen großen Spielraum für die spätere Implementierung und erzwingt gleichzeitig
auch die Eingrenzung des Systems durch weitere Anforderungen, damit dieses erfolgreich modelliert und implementiert werden kann.

Einige Fragen, welche das Epic noch offen lässt sind zum Beispiel:
\begin{itemize}
	\item Was bedeutet digital verwalten?
	\item Soll eine Web-, Desktop- oder Mobile-Anwendung entwickelt werden?
	\item Welche Art von Interaktion soll für die Professoren und Studierenden möglich sein?
\end{itemize}

Die Antworten auf diese Fragen stellen weitere Anforderungen an das System dar.
Diese werden wiederum als User Stories formuliert und weiterverarbeit.
Selbstverständlich können auch hier nocheinmal User Stories entstehen, welche
zu generell sind und deshalb weitere Verfeinerung benötigen.
Tatsächlich handelt es sich dann um ein weiteres Epic, welches wiederum durch den
vorher erläuterten Prozess verfeinert werden muss.
Hierbei ist es allerdings wichtig, dass User Stories nicht bis in das kleinste Detail
aufgeteilt werden dürfen \cite[p. 6]{cohn_user_2004}.
Wie in der Definition erwähnt gehört zu einer User Story neben der \emph{Card}, der Formulierung,
auch die \emph{Conversation}, in welcher die Details der User Story geklärt werden.
Die Absicht User Stories so spezifisch wie möglich zu formulieren würde hier nur zu überflüssiger
Redundanz führen, welche schlussendlich die Effizienz des Entwicklungsteam senkt.

Anhand dieser Überlegungen sind folgende zwei User Stories als Verfeinerung des oben genannten Epics verfasst:

\vspace{1em}
\texttt{Als \underline{Professor} möchte ich \underline{die Kursverwaltung per }\\
	\hspace*{2em} \underline{ Weboberfläche bedienen können}, damit\\
	\hspace*{6em} \underline{ich von unterschiedlichen Geräten }\\
	\hspace*{14em} \underline{ darauf zugreifen kann.}}
\vspace{1em}

Diese User Story geht auf die ersten beiden Fragen ein und stellt eine in diesem Punkt
eine Spezialisierung der Anforderung dar.

Hierbei sei anzumerken, dass es ausgehend von dem Epic keine eindeutig richtige oder
falsche Spezialisierung gibt.
In diesem konkreten Fall wären alle drei Möglichkeiten,
nämlich eine Web-, Desktop- oder Mobile-Anwendung zu entwickeln, korrekt gewesen.
Das Epic lässt die Interpretation von \emph{digital} offen.

Aus diesem Grund wird in vielen Fällen für die Spezialisierung des Epics weitere Kommunikation
mit dem Kunden des System von Nöten sein.
Meist kann nur dieser die korrekte Interpretation der Anforderung liefern.

Wie und ob diese Kommunikation stattfindet ist allerdings Sache des (agilen) Vorgehensmodells, welches
das Entwicklerteam anwendet.

\vspace{1em}
\texttt{Als \underline{Professor} möchte ich \underline{die Kursinformationen }\\
	\hspace*{4.5em} \underline{ verändern können}, damit \underline{sie richtig} sind.}
\vspace{1em}

In dieser zweiten User Story findet eine Spezialisierung der dritten Frage statt.
Bei dieser Frage geht es nicht darum, die Mehrdeutigkeit eines verwendeten Begriffs zu klären,
sondern konkrete Beispiele aus einem durch das Epic aufgespannten Anforderungsbereich
zu formulieren.

So könnten in Zukunft noch weitere User Stories hinzukommen, die das Epic im Bezug auf die dritte
Frage spezialisieren.
Zum Beispiel könnte eine weitere User Story die eine mögliche Interaktion der Studierenden beschreiben:

\vspace{1em}
\texttt{Als \underline{Studierender} möchte ich \underline{mich für die Teilnahme }\\
	\hspace*{2em}\underline{ an einem Kurs registrieren },\\
	\hspace*{4em}damit \underline{mir diese Teilnahme angerechnet wird}.}
\vspace{1em}

\subsection{Was sind gute User Stories?}
Die Definition von User Stories und Epics beschreibt die Struktur und die Rahmenbedingungen bei der Erstellung einer User Story.
In der Praxis bleibt ausgehend von dieser Definition aber die Frage offen, welche Merkmale eine gute User Story aufweist.

\cite{wake_invest_2003} hat für diesen Zweck sechs Eigenschaften für eine gute User Story unter dem Akronym \textbf{INVEST} zusammengefasst.
\begin{description}
	\item[Independent:] Eine gute User Story ist nicht von anderen User Stories abhängig.
	\item[Negotiable:] Eine gute User Story stellt keine unveränderbare Spezifikation dar, sondern dient als Diskussionsgrundlage.
		Die Implementationsdetails werden nicht vorher festgelegt, sondern über den Lebenszyklus der User Story als Teil der Conversation
		erarbeitet.
	\item[Valuable:] Eine gute User Story stellt einen Mehrwert für den Kunden dar.
	\item[Estimatable:] Der Aufwand einer guten User Story ist schätzbar.
	\item[Small:] Eine gute User Story ist klein und umfasst nur eine einzelne Anforderung, welche in kurzer Zeit implementiert werden kann.
	\item[Testable:] Die Erfüllung einer guten User Story ist prüfbar sein.
\end{description}

\section{Automatische Verarbeitung von User Stories am Beispiel von Cucumber}
Epics und User Stories werden, ausgehend von der oben genannten Definition, immer in einer bestimmten Struktur formuliert.
Diese Struktur unterstützt nicht nur menschliche Leser, sondern ermöglicht auch die computergestützte Weiterverarbeitung der User Story.
Ein Beispiel wo dies zum Einsatz kommt ist die Software \emph{Cucumber}.

``Cucumber ist ein Tool um Akzeptanztest, welche in verständlicher Sprache verfasst sind, automatisiert auszuführen'' \cite{the_cucumber_open_source_project_cucumber_2025}.
Mit Hilfe von Cucumber ist es möglich sogenannte \emph{Features} in einer von aktuell 80 gesprochenen Sprachen zu verfassen.
Dabei muss lediglich die simple Gherkin-Grammatik eingehalten werden.

Basierend auf diesen Features kann Cucumber dann automatische Akzeptanztests für das jeweilige Feature durchführen.
Insbesondere können durch diese automatisierte Test-erzeugung auch neu erstellte User Stories direkt mit dem bestehenden System
überprüft werden. Dadurch kann direkt erkannt werden, an welche Teile einer User Story noch Implementationsbedarf haben und welche
Teile möglicherweise schon durch bestehenden Quellcode abgedeckt ist.

\subsection{Workflow an einem Beispiel}
In diesem Abschnitt wird für eine im vorhergehenden Kapitel formulierte User Story beispielhaft eine Umsetzung
mit der Gherkin-Syntax und Cucumber durchgeführt.
Die gewählte User Story lautet:

\texttt{Als Professor möchte ich die Kursinformation \\verändern können, damit sie richtig sind.}

Um diese User Story in der Gherkin-Grammatik auszudrücken, muss lediglich folgendes Schema befolgt werden.

\vspace*{-.3em}
\begin{minted}{cucumber}
Feature: <Titel der User Story>

Scenario: <Card der User Story>
    Given <Vorbedingung für den Test>
    When  <Veränderung, die getestet werden soll>
    Then  <Akzeptanzbedingung des Tests>
\end{minted}
\vspace*{-.5em}

Wie dieses Schema für die oben genannte User Story umgesetzt werden kann ist in Listing \ref{listing:1} zu sehen.

\begin{listing}[!ht]
	\inputminted{cucumber}{cucumber/course_modification.feature}
	%\vspace*{-1em}
	\caption{\texttt{course\_modification.feature}}
	\label{listing:1}
\end{listing}

Um basierend auf solch einer Feature-Datei nun automatisierte Tests durchzuführen, müssen für die einzelnen Testabschnitte
\texttt{Given}, \texttt{When}, \texttt{Then} nun noch Template-Testfunktionen implementiert werden, welche bei der Testdurchführung
die in der Feature-Datei spezifizierten Parameter, in diesem Fall die Strings \texttt{"Software Enginearing"} und
\texttt{"Software Engineering"}, übergeben bekommen.
Der für diesen Zweck im Beispiel verwendete Quellcode ist in Listing \ref{listing:2} zu finden.

\begin{listing}[!ht]
	\begin{tcolorbox}[colframe=black, colback=white, opacityback=1.0, sharp corners, boxrule=.4pt, width=\linewidth-4pt]
		\inputminted[linenos, firstline=9, breakafter=_, xleftmargin=2pt, numbersep=6pt, frame=none]{java}{cucumber/StepDefinitions.java}
		\vspace{-1em}
	\end{tcolorbox}
	\vspace{-1em}
	\caption{\texttt{StepDefinitions.java}}
	\label{listing:2}
\end{listing}

Das hier vorgestellte Beispiel und der zugehörige Quellcode sind online auf GitHub in folgenden Repository verfügbar:
\href{https://github.com/Beleg-01-Requirements-Engineering/cucumber-example}{\texttt{https://github.com/Beleg-01-Requirements-Engineering/
		cucumber-example}}.
Dort ist ebenfalls eine Anleitung zum Ausführen der Tests zu finden.


\section{Agile Vorgehensmodelle}

\subsection{Requirement Engineering in Kanban}

Für das Requirement Engineering (RE) in Kanban wird dem Team viel Spielraum gelassen, 
um seine eigenen Methoden und Vorgehensweisen zu entwickeln. Anders als bei Scrum, sind 
in Kanban keine spezifischen Rollen für einzelne Teammitglieder vorgesehen. Eine 
Spezialisierung einzelner Mitglieder auf bestimmte Bereiche, wie bspw. das RE, ist trotzdem 
möglich.

In Kanban wird vorgesehen, dass die Requirements und Epics in enger Zusammenarbeit mit 
den Stakeholdern erarbeitet werden. Dabei ist für den Austausch mit dem Stakeholder keine 
spezifische Rolle oder Methodik vorgesehen, sodass meist ein oder mehrere Teammitglieder 
diese Aufgabe dynamisch übernehmen können. \cite{agileprocesses}

Die zu den Epics gehörenden User Stories werden meist in enger Zusammenarbeit im Team erstellt, 
geschätzt, priorisiert und ihre Akzeptanzkriterien festgelegt. Dazu steht dem Team eine Vielzahl 
von Methoden zur Verfügung. Einige dieser Methoden werden in einem späteren Kapitel vorgestellt. 
Es wird dabei oft versucht die entstehenden User Stories so zu konzipieren, dass sie als vertikale 
Scheibe des Gesamtsystems umgesetzt werden können. Das bedeutet, dass ein eigenständiges, vorzeigbares 
Produkt entsteht, das sich durch die Gesamte Architektur des Systems zieht. Dies ist allerdings 
vor allem in komplexen Systemen nicht immer Möglich. Die technischen Details für die Implementierung 
der User Story werden in Teams geklärt, damit die relevanten Teammitglieder sich auf eine Vorgehensweise 
einigen können. \cite{agileprocesses}

Wie größere User Stories in Kanban heruntergebrochen und welche Methoden dafür genutzt werden, bleibt 
dem Team vollständig überlassen. Eine Methode, die man für das Herunterbrechen von User Stories verwenden 
kann, wird in Kapitel \ref{sec:breakedown} vorgestellt. Der Zeitaufwand für eine User Story sollte am Ende ein paar 
Tage betragen, aber nicht mehrere Wochen übersteigen. Gegebenenfalls kann das Team auch entscheiden 
eine User Story in Tasks, also noch kleinere Aufgaben, aufzuteilen. \cite{agileprocesses}

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{images/Kanban-Board-mit-userstories.png}
  \caption{Kanban Board mit User Stories}
    \label{fig:kanban-board}
  \Description{}
\end{figure}

In Kanban werden die User Stories auf einem Kanban-Board visualisiert, auf dem sie in Abhängigkeit von 
ihrem Bearbeitungszustand verschoben werden \ref{fig:kanban-board}. Meist werden die User Stories in den einzelnen 
Zuständen nach ihrer Priorität geordnet. In Kanban kann der Inhalt des Kanban-Boards und die User Stories 
darauf zu jeder Zeit verändert werden. So können User Stories von dem Board genommen werden, angepasst 
werden, oder bei Bedarf in kleinere User Stories oder Tasks aufgeteilt werden. So kann das Team sehr schnell 
auf Änderungen reagieren. \cite{agileprocesses}

In Kanban liegt es im Ermessen des Teams, wann aus den fertig umgesetzten User Stories ein neuer Release 
erstellt wird, sodass das Team flexibel entscheiden kann, wie lang ein Feedbackloop ist. \cite{agileprocesses}

\subsubsection{Vorteile und Nachteile von Requirement Engineering in Kanban}

Die Art und Weise, wie das RE in Kanban durchgeführt wird, ermöglicht es dem Team, sehr flexibel zu Arbeiten. 
Das liegt daran, dass die zu bearbeitenden User Stories jeder Zeit auf dem Kanban-Board angepasst, entfernt, 
hinzugefügt und umgeordnet werden können. Dadurch kann das Team schnell auf Änderungen wie Bugs und Requirementsänderungen 
reagieren. Das Kanban-Board ermöglicht es auch dem Team und dem Stakeholder leichter den Überblick über den 
Fortschritt des Projekts zu behalten und hilft dabei die Entwicklung zu dokumentieren.

Eine Studie in \cite{agileprocesses} zeigt, dass ein gutes Team mit Kanban konstant und iterativ entwickeln und sich zusätzlich 
an dynamisch verändernde Anforderungen anpassen kann. So wird das Team dazu angeregt, Lösungen aus eigener 
Initiative zu entwickeln, ohne an eine feste Ablaufstruktur gebunden zu sein. \cite{reqkanban}

Durch das RE in Kanban entstehen allerdings auch einige Herausforderungen für das Team. Aufgrund der flexiblen 
Struktur, braucht das Team eine große Selbstverantwortung und Teamdisziplin. So muss es selbständig RE in den 
dynamischen Entwicklungsprozess integrieren. Auch die Kommunikation und den Austausch mit den Stakeholders muss 
das Team passend einplanen. Vor allem bei größeren, oder unerfahrenen Teams kann dieser zusätzliche Aufwand für 
die Planung der Ablaufstruktur ein größeres Problem darstellen. \cite{kanbannod}

\subsection{Requirement Engineering in Scrum}

Anders als bei Kanban, ist in Scrum für das Team eine dedizierte Phase vor einem Sprint für das RE bestimmt. In dieser 
beschäftigt sich das Team mit den User Stories für den nächsten Sprint Backlog. Diese Phase wird als Sprint Planning bezeichnet. \cite{reinscrum}

Ein weiterer Unterschied zu Kanban besteht darin, dass bei dem RE in Scrum bestimmte vordefinierte Rollen im Team eine 
große Bedeutung spielen. So ist z.B. der Scrum Master dafür verantwortlich sicherzustellen, dass das Team sich mit den 
User Stories ordentlich beschäftigen kann. Die wichtigste Rolle für das RE in Scrum ist der Product Owner. Dieser ist 
dafür verantwortlich den Product Backlog zu Verwalten. Das Bedeutet, dass er für das Formulieren und herunterbrechen der 
Epics und User Stories zuständig ist, wobei er dafür auch teile des Teams mit einbeziehen kann. Deshalb ist er auch für 
das Ermitteln der Requirements der Stakeholder zuständig und dient oft auch als direkter Ansprechpartner für diese. \cite{reinscrum}

Weiterhin ist er dafür zuständig die User Stories im Product Backlog nach ihrer Priorität zu ordnen und auf ihre Machbarkeit 
zu kontrollieren. Eine Methode, mit der man User Stories nach ihrer Priorität ordnen kann, wird in Kapitel \ref{sec:priorization} erklärt. 
Er soll auch während des Sprint Plannings geeignete User Stories dem Team kommunizieren, um sicherzustellen, dass das Verständnis 
des Teams mit dem des Stakeholders vereinbar ist. \cite{reinscrum}

Das Team selbst hat hinsichtlich des RE die Aufgabe, während des Sprint Plannings die einzelnen User Stories für den Sprint 
Backlog auszuwählen und deren Aufwand zu schätzen. Eine Methode zum Schätzen des Aufwands, wird in Kapitel \ref{sec:effort} vorgestellt. 
Weiterhin muss das Team sich im Sprint Planning auf die technischen Details der Implementierung der User Stories einigen. [4]

In Scrum sind Epics ein größeres Themengebiet aus zusammengehörenden Requirements. Sie repräsentieren einen Themenkomplex, der 
zu groß ist, um ihn in einem Sprint vollständig zu implementieren. \cite{reinscrum}

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{images/sprint-burndown2.png}
  \caption{Burndown Chart für einen 2 Wochen Sprint}
    \label{fig:burndownchart}
  \Description{}
\end{figure}

User Stories in Scrum stellen als Inhalt des Sprint Backlogs die Ziele eines Sprints dar. Sie helfen dem Team dabei den Fortschritt 
des Sprints in z.B. einem Burndown Chart zu erfassen. Dabei sollten die User Stories einen kleinen und ähnlichen Umfang haben, sodass 
sich die Linie für die Abarbeitung der Story Points eines Sprints an eine linear fallende Linie annähert (siehe Abb.). So kann das 
Team Leichter erkennen, ob sie den Zeitplan für den aktuellen Sprint einhalten können. Falls erkannt wird, dass der Sprint nicht planmäßig 
verläuft, kann das Team über die Daily Scrums versuchen Gegenmaßnahmen einzuleiten. Sind die User Stories zu groß gewählt, fällt der 
Graph auf dem Burndown Chart gegen Ende des Sprints immer stärker ab, was oft dazu führt, dass zu spät erkannt wird, dass der Zeitplan 
nicht eingehalten werden kann. \cite{reinscrum} 

Ein grober Richtwert, wie klein die User Stories sein sollten, liefert \cite{humanizingwork}, 
in dem definiert wird, dass die Größe einer User Story in Scrum zwischen \( \frac{1}{6} \) und \( \frac{1}{10} \) der Velocity liegen soll. Bei der Velocity handelt 
es sich dabei um die Geschwindigkeit der Entwicklung in einem Sprint. Sie wird oft in Form von Story Points ausgedrückt und wird vor 
beginn des Sprints festgelegt. \cite{humanizingwork}

Bei dem Zusammenstellen des Sprint Backlogs, sollte darauf geachtet werden, dass die verwendeten User Stories zusammen ein auslieferbares 
Produkt bilden, dass am Sprintende den relevanten Stakeholders als neues Release vorgestellt werden kann. Dabei kann sich der Stakeholder 
am Sprint Backlog orientieren, um besser einzuschätzen, ob das Resultat des Sprints seinen Erwartungen entspricht. \cite{reinscrum}

\subsubsection{Vorteile und Nachteile von Requirement Engineering in Scrum}

Das RE in Scrum profitiert von dem klar Strukturierten Ablaufplan für jede Iteration. So sorgt das Sprint Planning dafür, dass sich das 
Team für ein vordefinierte Zeit nur darauf konzentriert welche User Stories  und wie diese umgesetzt werden sollen. Das erleichtert es vor 
allem bei unerfahrenen Teams alle Mitglieder auf die gleiche Verständniseben bezüglich der Ziele des Sprints zu heben. Das Team muss sich 
also keine Gedanken darüber machen zu versuchen das RE dynamisch in die Entwicklung einzubinden.

Es ist auch vorteilhaft, dass die Stakeholder in regelmäßigen Abständen über den Fortschritt des Projekts anschaulich informiert werden und 
dadurch die Kommunikation mit diesen erleichtert und oft klarer wird. Dank der festen Iterationsintervalle kann das Team die verwendeten 
Methoden bei Bedarf leichter anpassen, um folgende Sprints zu verbessern. So kann z.B. die Schätzungsmethode zwischen Sprints einfach gewechselt 
werden, wenn die aktuelle Methode nicht die geforderte Genauigkeit liefert.

Weiterhin ist ein Großteil des RE auf den Product Owner ausgelagert, wodurch das restliche Team sich besser auf die Implementierung konzentrieren kann.

Zwar erleichtert die feste Ablaufstruktur die Planung des RE in Scrum, allerdings macht sie es auch unflexibler. So ist es in Scrum nicht 
vorgesehen den Sprint Backlog während der Sprintphase anzupassen, was es dem Team erschwert auf kurzfristige Änderungen zu reagieren. Dies 
kann vor allem bei Bugs, sowie integriertem Kundensupport und Customizing zu Problemen mit Stakeholdern führen. Das liegt daran, dass in 
diesen Kategorien sehr kurzfristig Anforderungen entstehen können, die auch eine sehr hohe Priorität aufweisen können.

Weiterhin hängt der Erfolg eines Sprints stark von der Arbeit ab, die während des Sprint Plannings geleistet wurde, da die Ergebnisse aus 
dieser Phase während eines Spints nicht mehr geändert werden sollen. Dies kann dazu führen, dass ein schwerer Fehler im Sprint Planning zum 
Abbruch des Sprints führen kann. Ähnliches gilt auch für den Product Owner. Dieser nimmt zwar dem restlichen Team einen signifikanten Teil 
des RE ab, hat aber entsprechend viel Verantwortung. Der Erfolg des Projekts hängt davon ab, dass er die Requirements der Stakeholder korrekt 
analysiert und verständlich an das Team kommuniziert.

\subsection{Konkrete Anwendungsmethoden für die Kontrolle von User Stories}

Bei der Betrachtung der agilen Methoden, wurde in dieser Arbeit oft darauf hingewiesen, dass die verwendeten User Stories gewisse Kriterien 
erfüllen sollten. Zu diesen Kriterien gehört z.B. dass die User Story weit genug heruntergebrochen ist, ihr Aufwand geschätzt und sie Priorisiert 
wurde. Im Folgenden wird zu diesen Kriterien jeweils eine konkrete Methodik vorgestellt. Weiterhin wird auch noch angerissen, was eine Defnition of 
Ready (DoR) und eine Definition of Done (DoD) im Zusammenhang mit User Stories ist.

\subsubsection{Herunterbrechen von User Stories} \label{sec:breakedown}

Eine Methode, um eine zu große User Story richtig herunterzubrechen, wurde von humanizing Work veröffentlicht. Dabei handelt es sich um ein Story 
Splitting Flowchart, das von Richard Lawrence entwickelt wurde \ref{fig:breakedownt}. Diese Methode wurde hauptsächlich für Scrum entwickelt, kann aber auch 
in anderen agilen Methoden verwendet werden. \cite{humanizingwork}

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{images/HW-Story-Splitting-Flowchart-Thumbnail.jpg}
  \caption{Flowchart zum Herunterbechen von User Stories \cite{humanizingwork}}
    \label{fig:breakedownt}
  \Description{}
\end{figure}

Bei Dieser Methode wird zunächst geprüft, ob die User Story das INVEST-Modell erfüllen. Sollte dies nicht der Fall sein, muss die User Story nochmal 
überarbeitet werden. Wenn die Größe der User Story über dem vordefinierten Bereiche liegt (hier zw. \( \frac{1}{6} \) und \( \frac{1}{10} \) der Velocity), kann mit dem Herunterbrechen 
fortgefahren werden. \cite{humanizingwork}

In dem Flowchart werden dafür verschiedene Kategorien vorgeschlagen, nach denen man die User Story weiter herunterbrechen kann. Zu diesen Kategorien 
gehören die verschiedenen Arbeitsschritte, Operationen, Buisenessregeln, Datentyparten und Schnittstellen. Weiterhin kann man sie auch nach dem größten 
Aufwand, der Komplexität und der Entscheidung, ob nichtfunktionale Anforderungen erst später umgesetzt werden können, heruntergebrochen werden. \cite{humanizingwork}

Nachdem die User Story nach einer der Kriterien heruntergebrochen wurde, werden die entstandenen Stories noch geprüft. Dabei Müssen die neuen Stories 
unter anderem noch dem INVEST-Modell entsprechen, ungefähr den gleichen Umfang aufweisen, dieser Umfang innerhalb des vorgegebenen Bereichs liegen und 
keiner der Stories redundant ist. Wenn alle Schritte in dem Flowchart richtig umgesetzt wurden, dann erhält man am Ende gute User Stories mit der 
gewollten Größe. \cite{humanizingwork}

\subsubsection{Aufwandschätzung von User Stories über Planning Poker mit Fibonacci-Zahlen} \label{sec:effort}

Von allen User Stories muss der Aufwand geschätzt werden um zu bestimmen, ob sie dem kleinen Umfang entsprechen, der in iterativen agilen Methoden 
benötigt wird. Eine Methode die man dazu anwenden kann, ist das Planning Poker mit Fibonacci-Zahlen. Dabei wird die Zahlenfolge als der Schätzwert verwendet. \cite{planingpoker}

Sie ist besser für das Schätzen geeignet als eine lineare Folge, da die Sprünge zwischen den einzelnen Zahlen nach oben immer größer werden. So wird 
verhindert, dass versucht wird große User Stories unrealistisch genau zu Schätzen. Das ist vorteilhaft, weil aus Beobachtungen hervorgegangen ist, dass 
die Aufwandschätzung mit zunehmendem Umfang der User Story immer ungenauer wird. \cite{planingpoker}

Das Planning Poker folgt einem festen Ablaufplan. Im ersten Schritt wird die User Story zunächst dem Team präsentiert. Daraufhin wird sie im Team diskutiert, 
damit ein einheitliches Verständnis entsteht. Im dritten Schritt schätzt dann jedes Mitglied den Aufwand mithilfe der Fibonacci-Zahlen. Welcher Aufwand genau 
geschätzt wird ist dem Team überlassen. Es kann z.B. die Story Points, oder die Komplexität geschätzt werden. \cite{planingpoker}

Anschließend werden die Ergebnisse der Schätzungen Präsentiert und die beiden Teammitglieder mit der größten Differenz stellen die Gründe für ihre Schätzung vor. 
Anschließend werden die Abweichungen im Team diskutiert. Wenn sich das Team in dieser Diskussion einigen kann, dann wird die Schätzung finalisiert, indem man z.B. 
den Median oder Mittelwert aller Schätzungen bildet. Sollte allerdings keine Einigung Zustandekommen, muss das Team den Prozess wieder ab der Diskussion über die 
User Story wiederholen. \cite{planingpoker}

\subsubsection{Priorisieren von User Stories mit MoSCoW-Methode} \label{sec:priorization}

User Stories müssen priorisiert werden, damit sie richtig zugewiesen und eingeplant werden können. Dabei müssen die Abhängigkeiten von User Stories untereinander 
beachtet werden, wenn diese vorhanden sind. Für die Priorisierung kann man z.B. die MoSCoW-Methode verwenden. Dabei werden die User Stories in drei Kategorien eingeteilt. \cite{moscow}

Dazu gehören als erstes die Muss-Kategorie, in die User Stories eingeordnet werden, die absolut essentiell für die Grundfunktionalität sind und ohne die das 
Projekt nicht auskommt. In die Soll-Kategorie werden sie eingeordnet, wenn sie noch durchaus viel Wert für die Stakeholder aufweisen, aber für die Grundfunktionalität 
des Produkts nicht essenziell sind. Diese User Stories müssen also nicht unbedingt direkt in der ersten Version umgesetzt werden. Als drittes beinhaltet die Kann-Kategorie 
(Could) User Stories, die einen geringeren Wert für die Stakeholder haben und eher unter "Nice to have" einzuordnen sind. Die letzte Kategorie ist die Nicht-Kategorie 
(Will not), in der die User Stories fallen, die außerhalb des Scopes liegen und höchstens in Zukünftigen Versionen von Bedeutung sein könnten. \cite{moscow}

Die erfolgreiche Zuweisung der User Stories zu den entsprechenden Kategorien ist dabei stark von einer ordentlichen, vorausgehenden Aufwandschätzung abhängig. \cite{moscow}


\subsubsection{Definition of Ready (DoR) und Definition of Done (DoD)}

Damit das Team erkennt, wann eine User Story bereit für die Bearbeitung, oder fertig implementiert ist, definieren die meisten Unternehmen eine DoR und eine DoD. 
Bei einer DoR handelt es sich dabei um eine Liste von Kategorien, die alle User Stories erfüllen muss, bevor sie für die Umsetzung freigegeben wird. der Genaue Inhalt 
ist bei der DoR und der DoD dem Unternehmen überlassen. 

In dem DoR könnten durchaus folgende Kriterien enthalten sein: das INVEST-Modell ist erfüllt, der Aufwand wurde geschätzt und ist innerhalb des vordefiniertem Bereichs, 
die Priorisierung wurde durchgeführt, die Akzeptanzkriterien sind festgelegt und die technischen Details sind geklärt.

Bei den Akzeptanzkriterien handelt es sich um die Kriterien, die eine spezifische User Story erfüllen muss, damit sie als fertig gilt. Diese sind zwischen den verschiedenen 
User Stories durchaus unterschiedlich. Sie werden oft von Stakeholdern vorgegeben, können aber auch nichtfunktionale Anforderungen enthalten, oder von dem erfolgreichen 
Abschluss vordefinierter Tests (z.B. Unit-Tests) abhängen.

In der DoD werden die Kriterien aufgelistet, die alle User Stories erfüllen müssen, damit sie als vollständig umgesetzt gelten. Zu diesen Kategorien können unter anderem 
folgende gehören: das Erfüllen der Akzeptanzkriterien, das Dokumentieren der Änderungen, das Bestehen alle Tests und die Abnahme durch den Product Owner oder Projektleiter.


\subsection{Feature-driven Development}
Im Folgenden wird erläutert, wie Epics und User Storys im Feature-driven Development (FDD) in den Arbeitsprozess integriert sind.

\subsubsection{Überblick über FDD}
Das Konzept des Feature-driven Development wurde erstmals in Kapitel 6 von \cite{coad99} beschrieben.
Im Zentrum dieses Ansatzes steht dabei der Begriff des \emph{Feature}, das dort als ``small client-valued functionality'' definiert wird, also eine Funktionalität, die einen konkreten Nutzen für den Kunden oder Anwender hat.

Ein Feature wird in der folgende Form beschrieben:

\begin{quote}
	\texttt{<Aktion>\hspace{5ex}<Ergebnis>\hspace{5ex}<Objekt>}
\end{quote}

Ein Beispiel für ein solches Feature ist:

\begin{quote}
	\texttt{Verwalte die Informationen des Kurses.}
\end{quote}

Diese prägnante Formulierung hat den Vorteil, dass sie die Verständlichkeit für den Kunden und andere Stakeholder erleichtert.
Die Entwicklungszeit eines Features ist auf wenige Stunden bis maximal zwei Wochen beschränkt.

FDD eignet sich besonders gut für große Softwareprojekte mit vielen Entwickler, welche dann in verschiedene Teams aufgeteilt werden.
Zusätzlich zu den Entwicklungsteams wird ein Planungsteam gebildet, welches aus erfahrenen Softwarearchitekten und Domainexperten besteht.

FDD folgt dabei einem klar strukturierten Prozess, der in fünf Phasen gegliedert ist. Diese Phasen lassen sich in zwei Bereiche einteilen: die Aufgaben des Planungsteams und die der Entwicklungsteams. Das Vorgehen wird in \cite{coad99} folgendermaßen beschrieben:

Zunächst wird ein Objektmodell der Software entwickelt (\emph{Phase 1: Develope an Overall Model}).
Anschließend wird eine Liste von Features erstellt (\emph{Phase 2: Build a Feature List}).
Darauf aufbauend wird für jedes Feature ein Entwicklungsplan erstellt (\emph{Phase 3: Plan by Feature}).
Jedem Entwicklungsteam werden dann ein oder mehrere Features zugeordnet.
Die Teams erarbeitet zunächst ein Design-Paket für die jeweiligen Features (\emph{Phase 4: Design by Feature}),
anschließend erfolgt die Implementierung (\emph{Phase 5: Build by Feature}).

Dieses strukturierte, inkrementelle Vorgehen soll ermöglichen, regelmäßig sichtbaren Fortschritt zu liefern, ohne die Prozesse dabei unnötig zu verkomplizieren.

% Graphik fehlt noch

\subsubsection{Feature vs. User Story}

Sowohl Features als auch User Stories dienen dazu, Anforderungen in überschaubare Teilprobleme zu zerlegen, welche einen konkreten Nutzen für den Anwender haben. Beide sind so formuliert, dass sie für den Kunden und andere Stakeholder verständlich bleiben.

Trotz dieser Gemeinsamkeiten gibt es wesentliche Unterschiede zwischen den beiden Konzepten:
Bereits die unterschiedliche Formulierung zeigt, dass User Stories stärker aus der Sicht des Kunden beschrieben werden, während Features sich primär auf die funktionale Umsetzung konzentrieren.

Ein weiterer Unterschied ist die Vorgabe der Entwicklungszeit.
Bei Features steht die Planbarkeit im Vordergrund, welche durch die Vorgabe von wenigen Stunden bis max. 2 Wochen Entwicklungszeit sichergestellt wird.
In \cite{palmer02} wird zudem betont, dass ein Feature nicht nur eine triviale Methode sein sollte, die lediglich einen Attributwert zurückgibt.
Bei User Stories ist es hingegen durchaus zulässig, auch kleinere Einheiten zu definieren, wie bereits in einigen Beispielen gezeigt wurde.

Weiterhin unterscheidet sich auch die Einbindung in den Entwicklungsprozess.
Während User Stories unter anderem dazu dienen, Objekte und Klassen zu identifizieren, werden Features im Kontext von FDD typischerweise aus der bereits bestehenden Softwarearchitektur bzw. dem Ablaufmodell abgeleitet \cite{palmer02}.
Dadurch sind User Stories im Entwicklungsprozess vor Features einzuordnen.

Features und User Stories lassen sich also nicht miteinander vergleichen. Eine User Story kann ein oder mehrere Features umfassen, ein einzelnen Feature kann aber auch in mehreren User Stories vorkommen\cite{coad99}.

% Beispiel fehlt noch

\subsubsection{Rolle von User Stories und Epics in FDD}

Im Gegensatz zu Kanban und Scrum basiert das Konzept des Feature-driven Developments nicht grundlegend auf Epics und User Stories.
Dennoch können sie  in Phase 1 bei der Modellierung des Gesamtmodells hilfreich sein.
In den späteren Phase können sie zudem das Identifizieren von Features unterstützen.
Obwohl die Kommunikation in FDD überwiegend auf Features ausgerichtet ist, bieten User Stories eine nützliche Ergänzung bei der Kommunikation zwischen dem Planungsteam und den Entwicklungsteams sowie zwischen dem Planungsteam und dem Kunden.
Besonders in der Zusammenarbeit mit Stakeholdern sind User Stories hilfreich, da sie die Perspektive des Anwenders stärker in den Vordergrund rücken.
Zudem können sie bspw. in der Dokumentation eines Domain-Walkthroughs eingesetzt werden.

Epics und User Stories übernehmen in FDD üblicherweise nicht die Rolle der Priorisierung und Planung - diese wird durch Features abgedeckt. Stattdessen dienen sie als zusätzliches Hilfsmittel für die Modellierung und zur Verbesserung der Kommunikation. Diese Rolle sollte allerdings nicht unterschätzt werden, da eine klare und effiziente Kommunikation zwischen dem Planungsteam und den Entwicklungsteams in FDD von entscheidender Bedeutung ist.

Zusammenfassend lässt sich festhalten, dass User Stories und Epics zwar keine zentrale Rolle in FDD einnehmen, aber eine wertvolle Ergänzung darstellen können.

\section{Diskussion}

\begin{itemize}
	\item Vorteile? Nutzen?
	\item Risiken?
	\item Probleme bei der Anwendung von User Stories und Epics: unklare Anforderungen, Gefahr der Über- oder Unterpriorisierung.
	\item aufzeigen wie User Story und Epic helfen um agil arbeiten zu können
\end{itemize}

\section{Zusammenfassung und Ausblick}

\begin{itemize}
	\item Zusammenfassung: User Stories und Epics als Mittel zur Förderung von effektiver Kommunikation und Anpassungsfähigkeit.
	\item Ausblick:
	      \begin{itemize}
		      \item Potenziale durch KI-gestützte Tools zur automatischen Erstellung oder Analyse von User Stories.
	      \end{itemize}
\end{itemize}


\bibliographystyle{ACM-Reference-Format}
\bibliography{01-Requirements-Engineering}

\appendix

\section{Anhang 1}

\subsection{Übungsaufgaben}
\subsubsection{Epics und User Stories}
Ein Lebensmittelverwaltungssystem soll Privatpersonen helfen ihre gelagerten Lebensmittel abzurufen,
den Lebensmittelverbrauch zu überwachen und bei der Essensplanung unterstützen.

Finden Sie eine geeignete Anforderung für dieses System, welche einem Epic entspricht und formulieren Sie drei zugehörige
User Stories mit Hilfe der Gherkin-Grammatik!


\end{document}
\endinput
